{
  "Content": "This release is hella backwards incompatible. Read carefully, and ask in\nIRC ([#concourse](irc://irc.freenode.net/concourse)) if you need help!\n\nWe won’t be making such drastic changes after 1.0, but as long as we’re\nstill figuring things out, we don’t want to collect tech debt or land on\nthe wrong set of primitives.\n- _Backwards-incompatible:_ the progression of artifacts through a build\n  plan has been made more explicit.\n  \n  Previously there was basically a working directory that would be\n  streamed from step to step, and `aggregate` steps were relied on to\n  place things under subdirectories, which is how inputs to tasks were\n  satisfied.\n  \n  Now, as a plan executes, each step’s produced artifact (for example a\n  `get` step’s fetched bits or the result of a `task`’s execution) are\n  stored in a pool, with the source named after the step.\n  \n  This change affects many things, but the primary things you’ll notice\n  are as follows:\n  - When executing a `task` step, its inputs are collected from the\n    pool, rather than blindly streamed from the previous step. This\n    means `aggregate` is no longer required to satisfy task inputs, and\n    can now be removed if it’s only wrapping one step.\n    \n    Tasks are now _required_ to list their set of inputs, otherwise no\n    inputs will be streamed in. This is backwards-incompatible, but has\n    many advantages: it’s more explicit, more efficient, and makes it\n    clearer where the dependent inputs will be placed in a task’s\n    working directory when it runs.\n    \n    When a task completes, its resulting working directory is added to\n    the pool, named after the task itself. This is how you would `put`\n    using artifacts generated by tasks.\n  - The `file` attribute of a `task` step must now qualify the path with\n    the name of the source providing the file.\n  - When executing a `put` step, _all_ sources are fetched from the\n    pool. Later on we may introduce a change so that `put` steps declare\n    their dependencies, but for now streaming everything in is the\n    simplest path forward.\n    \n    The net effect of this is that any params referring to files in\n    `put` steps must now qualify the path with the source name, as\n    they’re all fetched into subdirectories.\n  - Now that there’s a flat pool of sources, later steps in a build plan\n    can now refer back to previously fetched (or generated) sources,\n    rather than having to fetch them again.\n  \n  So, if before you had a plan that looked like this:\n  \n  ``` racket\n  plan:               \n  - aggregate:        \n    - get: something  \n  - task: generate-foo\n    file: build.yml   \n  - put: foo-bucket   \n    params:           \n      from: foo       \n  ```\n  \n  ...it would now look like this:\n  \n  ``` racket\n  plan:                      \n  - get: something           \n  - task: generate-foo       \n    file: something/build.yml\n  - put: foo-bucket          \n    params:                  \n      from: generate-foo/foo \n  ```\n  \n  Notably, the redundant `aggregate` is gone, the `file` attribute of\n  the `task` step qualifies the filename with the name of the source\n  containing it, and the `put` step qualifies the path to `foo` with the\n  name of the task that it came from.\n  \n  Also, the `something/build.yml` task would now explicitly list its\n  inputs, if it wasn’t before. So that could mean changing:\n  \n  ``` racket\n  platform: linux              \n  \n  image: docker:///busybox     \n  \n  run:                         \n    path: something/some-script\n  ```\n  \n  ...to...\n  \n  ``` racket\n  platform: linux              \n  \n  image: docker:///busybox     \n  \n  inputs:                      \n  - name: something            \n  \n  run:                         \n    path: something/some-script\n  ```\n  \n  This has the advantage of making the task config more\n  self-documenting, and removes any doubt as to what inputs will be\n  placed where when the task starts.\n  \n  Note that listing inputs in the task config is not _new_, and if you\n  were already listing them before the semantics hasn’t changed. The\n  only difference is that they’re now required.\n- _Backwards-incompatible_: worker registration is now done over SSH,\n  using a new component called the\n  [TSA](https://github.com/concourse/tsa).\n  \n  To upgrade, you’ll have to change your manifest a bit:\n  - On your workers, replace the `gate` job with `groundcrew` and remove\n    the `gate` properties.\n  - The new `tsa` job template will have to be added somewhere, and\n    configured with the `atc` credentials (the same way `gate` used to\n    be configured).\n    \n    Colocating `tsa` with the `atc` works out nicely, so that you can\n    register its listening port `2222` with your routing layer (e.g.\n    ELB), which will already be pointing at the ATC.\n  \n  To compare, see the example AWS VPC manifest.\n  \n  The main upshot of this change is it’s _much_ easier to securely\n  register an external worker with Concourse. This new model only needs\n  the worker to be able to reach the ATC rather than the other way\n  around.\n- _Backwards-incompatible_: Consul services are now automatically\n  registered based on the jobs being colocated with the agent. For this\n  to work, you must edit your deployment manifest and move the\n  `consul-agent` job to the top of each job template list, and remove\n  your existing Consul services configuration from your manifest.\n- The `get` and `put` steps from a build’s execution can now be hijacked\n  after they’ve finished or errored. Previously they would be reaped\n  immediately; now they stick around for 5 minutes afterwards (same\n  semantics as `task`s).\n- The [S3 resource](https://github.com/concourse/s3-resource) now\n  defaults to the `us-east-1` region.\n- The [S3 resource](https://github.com/concourse/s3-resource) no longer\n  fails to check when the configured bucket is empty.\n- A new BOSH Deployment resource has been introduced. It can be used to\n  deploy a given set of release/stemcell tarballs with a manifest to a\n  statically configured BOSH target. The precise versions of the\n  releases and stemcells are overridden in the manifest before deploying\n  to ensure it’s not just always rolling forward to `latest`.\n"
}