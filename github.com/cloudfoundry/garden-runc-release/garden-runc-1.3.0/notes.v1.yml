{
  "Content": "* Verified with [grootfs-release v0.15.0](https://github.com/cloudfoundry/grootfs-release/releases/tag/v0.15.0)\r\n\r\nLots of nice little changes and two big ones: CPU maximums support and alpha/experimental support for running containers without root.\r\n\r\n## Experimental! Support for running containers without root\r\n\r\nThis is very much a v1 which we would not suggest running in production (yet!). It is now possible to run garden without needing root (other than for one-time setup). This increases the security posture of garden and the number of places where it can potentially be used. Manual instructions and known gaps in the attached doc: https://github.com/cloudfoundry/garden-runc-release/blob/develop/docs/rootless-containers.md. \r\n\r\nYou can also opt-in using the `experimental_rootless_mode` bosh property which will do all the work for you!\r\n\r\n**NOTE**: **Not ready - or secure - for production use yet**, but feedback very welcome!\r\n\r\n## CPU Maximums\r\n\r\nIt is now possible to request a maximum CPU limit proportional to the existing fair-share CPU limit. The previous cpu limit just ensured that if two containers competed for cpu they would receive it in proportion to their requested cpu share (in the Cloud Foundry use case, this meant in proportion to their memory limit). This meant, for example, if only one container was active on a host it could potentially consume all of the host's resources -- far more than were paid for. \r\n\r\nThe new `cpu_quota_per_share_in_us` property, which - if set - applies to all containers created on a host, enforces an additional _maximum_ amount of cpu usage in each quota period (which unless changed on the system is 100ms) in proportion to the existing shares limit. \r\n\r\n**Example:** Using Cloud Foundry as an example, since CF sets a container's cpu limit (`ContainerSpec.Limits.Cpu.LimitInShares`) based on the memory limit, if `cpu_quota_per_share_in_us` is set to 100 on a single-core system then a 64MB container will be able to use a maximum of 6.4ms (64 * 100us = 6400us = 6.4ms) of cpu every 100ms.\r\n\r\n## A Few More Things..\r\n\r\n- Container MTU now defaults to the MTU of the external network interface on the host rather than 1500. This is pretty much always what you want and avoids issues on environments with lower MTUs than the default.\r\n- We now strip all entries starting 127.* from resolv.conf on the host when setting up networking for the container. Since 127.* on the host can never be accessed in the container it's never the right thing for it to survive into the container's resolv.conf (and causes slow DNS lookups when it does).\r\n- Our CI now tracks container creation performance using [bucket bench](https://github.com/estesp/bucketbench)\r\n- Golang bumped to 1.8.0\r\n- Squished some misleading log messages. Feel good knowing you will no longer be misled (as much).\r\n\r\nEnjoy!"
}